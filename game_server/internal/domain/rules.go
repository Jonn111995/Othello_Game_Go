package domain

import (
	"errors"
	"log"
)

// rules.go は **純粋関数**で構成し、テストを容易にする。
// ここには "合法手判定" と "適用処理"、"スコア計算" などのロジックを置く。

var (
	ErrInvalidMove = errors.New("invalid move")
)

// Directions: 8 方向ベクトル
var dirs = [][2]int{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}}

// ValidAndFlips: (x,y) に color を置いた場合の反転セルを返す。
// - ボードは [y][x] のインデックスである点に注意
// - 戻り値: (合法かどうか, 反転される座標のリスト)
func ValidAndFlips(b *[8][8]Color, x, y int, color Color) (bool, [][2]int) {
	// ------------------------------------------------------------
	// 目的と設計方針（Why & What）
	// ------------------------------------------------------------
	// この関数は「与えられた座標 (x,y) に color を置いた場合に、
	// どのセルが反転されるか」を判定して座標一覧を返します。
	//
	// なぜサーバー側でこうした判定が必要なのか：
	// - サーバーが authoritative（唯一の真実）であるため、ゲームルールの最終判定
	//   はサーバーで行う必要がある。クライアントだけのチェックだとチートや同期不整合が発生する。
	// - 反転対象を事前に列挙して返すことで、呼び出し元（Actor など）が
	//   "検証のみ行う" → "適用(反転)は別関数で行う" といった責務分離を保てる。
	//   これにより単体テストやトランザクション設計（保存前に検証等）が容易になる。
	//
	// 設計上の選択理由:
	// - "局所的な flips を蓄える" 実装を採用：方向ごとに一時配列 (flips) を作り、
	//   その方向が有効なら全体配列 allFlips に追加する。これにより "途中で無効になった候補を
	//   取り消す" 必要が無くなり、実装がシンプルかつ正確になる。
	// - Color を整数 (Black=1, White=-1) にしているため、相手石は -color で表現でき、
	//   符号だけで判別できる（分岐を減らして若干高速）。
	// - ボードは固定サイズ [8][8] の配列を使う：サイズが固定であるため境界チェックが簡潔。
	//
	// 注意: 関数は純粋関数として扱える（副作用なし）。そのため並列で安全に呼べます。
	// ------------------------------------------------------------

	// --- 入力検証（early-return） ---
	// 範囲外チェックや既に埋まっているセルのチェックを先に行い、
	// 無効なケースはすぐに弾く。これにより不要な 8 方向走査を避ける。
	if x < 0 || x >= 8 || y < 0 || y >= 8 {
		return false, nil
	}
	if b[y][x] != Empty {
		return false, nil
	}

	// allFlips: すべての方向で判定された反転セルを集める
	var allFlips [][2]int

	// dirs は 8 方向（右、左、下、上、右下、右上、左下、左上）
	// 各方向ごとに走査を行う
	for _, d := range dirs {
		// cx, cy は現在見ているセルの座標（走査カーソル）
		cx, cy := x+d[0], y+d[1]
		// flips は "この方向で今まで見つかった相手石の座標" を一時保持する
		var flips [][2]int

		// 方向 d に沿って進む
		for cx >= 0 && cx < 8 && cy >= 0 && cy < 8 {
			// 1) 隣接セルが相手石である間は候補に追加して進める
			//    - 相手石が 1 個以上連続していないと、その方向で反転は成立しない
			if b[cy][cx] == -color {
				flips = append(flips, [2]int{cx, cy})
				cx += d[0]
				cy += d[1]
				continue
			}

			// 2) 自分の石が見つかった場合
			//    - かつ flips が空でない（= 相手石が 1 個以上連続している）なら
			//      ここまでの flips は確定的な反転対象となる
			if b[cy][cx] == color {
				if len(flips) > 0 {
					// この方向は有効。局所的 flips を全体の allFlips に統合する
					allFlips = append(allFlips, flips...)
				}
				// この方向の探索は終了（自分の石で封鎖された）
				break
			}

			// 3) 空セルまたはその他（盤端や Empty）に到達した場合
			//    - この方向は反転対象にならない -> flips を破棄して打ち切る
			break
		}
		// 次の方向へ
	}

	// --- 戻り値の意味 ---
	// allFlips が 1 つ以上あれば合法手（反転が発生する）
	// 計算量は定数（方向あたり最大 7 ステップ）なので O(1) と考えてよい
	//
	// なぜ反転座標を返す実装にしているのか（設計上の利点）:
	// - "検証" と "適用" を分離できる（ApplyMove はこの結果を受け取り副作用的に盤面を更新する）
	// - 反転座標を使えば、クライアントに対して "どの石が反転するか" を送ることも可能
	//   （視覚効果のためにサーバー通知を待たずクライアントでハイライトする等の UI 改善が容易）
	// - テストが容易になる（純粋関数として反転座標を期待値で比較できる）

	return len(allFlips) > 0, allFlips
}

// ApplyMove はボードにムーブを適用して反転を行う。内部で ValidAndFlips を使う。
// - ここでは副作用的にボードを更新する。ユースケースでは actor 内で実行する想定なので OK
func ApplyMove(b *[8][8]Color, x, y int, color Color) error {
	ok, flips := ValidAndFlips(b, x, y, color)
	if !ok {
		log.Println("Error Flips")
		return ErrInvalidMove
	}
	b[y][x] = color
	for _, f := range flips {
		log.Printf("Flip!: Color:%v", color)
		b[f[1]][f[0]] = color
	}
	return nil
}
